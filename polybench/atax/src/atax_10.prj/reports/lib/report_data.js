var areaJSON={"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[7.90063, 5.71829, 2.8053, 3.2368, 2.60417], "total":[5347, 9014, 19, 5, 192], "name":"System", "max_resources":[160660, 321320, 587, 192, 8033], "children":[{"name":"atax", "compute_units":1, "type":"function", "total_percent":[7.90063, 5.71829, 2.8053, 3.2368, 2.60417], "total_kernel_resources":[5347, 9014, 19, 5, 192], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 192 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"192b wide with 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'i\' (atax_10.c:5)", "type":"resource", "data":[131, 505, 0, 0, 0], "debug":[[{"filename":"atax_10.c", "line":5}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 and depth 1"}, {"type":"text", "text":"1 register of width 7 and depth 4 (depth was increased by a factor of 2 due to a loop initiation interval of 2.)"}, {"type":"text", "text":"1 register of width 32 and depth 1"}, {"type":"text", "text":"1 register of width 32 and depth 3"}, {"type":"text", "text":"1 register of width 32 and depth 4 (depth was increased by a factor of 2 due to a loop initiation interval of 2.)"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 7 width by 4 depth"}]}, {"name":"Variable: \\n - \'j\' (atax_10.c:5)", "type":"resource", "data":[52, 248, 0, 0, 0], "debug":[[{"filename":"atax_10.c", "line":5}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 and depth 4 (depth was increased by a factor of 4 due to a loop initiation interval of 4.)"}, {"type":"text", "text":"2 registers of width 32 and depth 1"}, {"type":"text", "text":"1 register of width 32 and depth 4 (depth was increased by a factor of 4 due to a loop initiation interval of 4.)"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 4 depth,\\n2 regs, 32 width by 1 depth"}]}, {"name":"atax_10.c:6 (buff_A)", "type":"resource", "data":[0, 0, 7, 0, 0], "debug":[[{"filename":"atax_10.c", "line":6}]], "details":[{"type":"table", "Memory system":"Stall-free", "Requested size":"16384 bytes", "Implemented size":"16384 bytes", "Memory Usage":"7 RAMs", "Number of banks":"1", "Bank width":"128 bits", "Bank depth":"1024 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Requested size 16384 bytes, implemented size 16384 bytes, stall-free, 2 reads and 2 writes. "}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}]}, {"type":"brief", "text":"Stall-free,\\n16384B requested,\\n16384B implemented."}]}, {"name":"atax_10.c:7 (buff_x)", "type":"resource", "data":[0, 0, 1, 0, 0], "debug":[[{"filename":"atax_10.c", "line":7}]], "details":[{"type":"table", "Memory system":"Stall-free", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Memory Usage":"1 RAM", "Number of banks":"1", "Bank width":"32 bits", "Bank depth":"64 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 1 read and 1 write. "}, {"type":"brief", "text":"Stall-free,\\n256B requested,\\n256B implemented."}]}, {"name":"atax_10.c:8 (buff_y_out)", "type":"resource", "data":[0, 0, 0, 0, 8], "debug":[[{"filename":"atax_10.c", "line":8}]], "details":[{"type":"table", "Memory system":"Stall-free", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Memory Usage":"8 MLABs", "Number of banks":"1", "Bank width":"128 bits", "Bank depth":"16 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 2 reads and 2 writes. "}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}]}, {"type":"brief", "text":"Stall-free,\\n256B requested,\\n256B implemented."}]}, {"name":"atax_10.c:9 (tmp1)", "type":"resource", "data":[33, 256, 1, 0, 0], "debug":[[{"filename":"atax_10.c", "line":9}]], "details":[{"type":"table", "Memory system":"Stall-free", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Memory Usage":"1 RAM", "Number of banks":"1", "Bank width":"32 bits", "Bank depth":"64 words", "Number of replicates":"1", "Number of private copies":"1", "Clock":"Running memory at 2x clock to support more concurrent ports", "Additional information":[{"type":"text", "text":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 2 reads and 2 writes. "}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}]}, {"type":"brief", "text":"Stall-free,\\n256B requested,\\n256B implemented."}]}, {"name":"atax.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 192, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"atax_10.c:3", "type":"resource", "data":[1, 192, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]]}]}, {"name":"Feedback", "type":"resource", "data":[14, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:3", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1, 0, 0, 0, 0], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:3", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"atax.B10", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[27, 19, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:38", "type":"resource", "data":[27, 19, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]]}]}]}, {"name":"atax.B12", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[721, 771, 8, 0, 25], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[721, 771, 8, 0, 25]}]}, {"name":"Feedback", "type":"resource", "data":[227, 240, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:43", "type":"resource", "data":[125, 151, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":43}]]}, {"name":"atax_10.c:44", "type":"resource", "data":[63, 42, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[39, 47, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 7], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:43", "type":"resource", "data":[20, 11, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":43}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"4-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"5-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}, {"name":"Iteration Initiation", "type":"resource", "count":1, "data":[12, 10, 0, 0, 0]}], "replace_name":"true"}, {"name":"atax_10.c:44", "type":"resource", "data":[463, 1243, 0, 0, 20], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "children":[{"name":"1-bit Or", "type":"resource", "count":3, "data":[3, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[74, 137, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"8"}]}]}, {"name":"Store", "type":"resource", "count":4, "data":[386, 1106, 0, 0, 20], "details":[{"type":"text", "text":"Store uses a Pipelined LSU"}, {"type":"brief", "text":"Pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"atax.B13", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 8, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:46", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":46}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"atax.B3", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[105, 103, 1, 0, 3], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[105, 103, 1, 0, 3]}]}, {"name":"Feedback", "type":"resource", "data":[51, 58, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:13", "type":"resource", "data":[13, 11, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[38, 47, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:13", "type":"resource", "data":[12, 8, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]], "children":[{"name":"1-bit Xor", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}, {"name":"Iteration Initiation", "type":"resource", "count":1, "data":[9, 7, 0, 0, 0]}], "replace_name":"true"}, {"name":"atax_10.c:14", "type":"resource", "data":[285, 245, 0, 0, 7], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":14}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[251, 221, 0, 0, 7], "details":[{"type":"text", "text":"Load uses a Pipelined LSU"}, {"type":"brief", "text":"Pipelined LSU"}]}, {"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"7"}]}]}], "replace_name":"true"}, {"name":"atax_10.c:15", "type":"resource", "data":[34, 24, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":15}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"8"}]}]}], "replace_name":"true"}, {"name":"atax_10.c:16", "type":"resource", "data":[34, 24, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":16}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"9"}]}]}], "replace_name":"true"}]}]}, {"name":"atax.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[77, 530, 1, 0, 7], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[77, 530, 1, 0, 7]}]}, {"name":"Feedback", "type":"resource", "data":[49, 103, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:13", "type":"resource", "data":[8, 5, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]]}, {"name":"atax_10.c:14", "type":"resource", "data":[8, 68, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":14}]]}, {"name":"atax_10.c:18", "type":"resource", "data":[31, 30, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":18}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[9, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:18", "type":"resource", "data":[5, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":18}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"2-bit Select", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}, {"name":"4-bit Integer Compare", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"atax_10.c:19", "type":"resource", "data":[2076, 1816, 0, 0, 56], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "children":[{"name":"Load", "type":"resource", "count":8, "data":[2008, 1768, 0, 0, 56], "details":[{"type":"text", "text":"Load uses a Pipelined LSU"}, {"type":"brief", "text":"Pipelined LSU"}]}, {"name":"Store", "type":"resource", "count":2, "data":[68, 48, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"6"}]}]}], "replace_name":"true"}]}]}, {"name":"atax.B6", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[18, 81, 0, 0, 8], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[18, 81, 0, 0, 8]}]}, {"name":"Feedback", "type":"resource", "data":[9, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:35", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 9], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:29", "type":"resource", "data":[26, 41, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[26, 41, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"9"}]}]}], "replace_name":"true"}, {"name":"atax_10.c:35", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]], "children":[{"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"atax.B7", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[69, 251, 0, 0, 18], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[69, 251, 0, 0, 18]}]}, {"name":"Feedback", "type":"resource", "data":[236, 1063, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:28", "type":"resource", "data":[58, 46, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":28}]]}, {"name":"atax_10.c:29", "type":"resource", "data":[115, 975, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]]}, {"name":"atax_10.c:35", "type":"resource", "data":[60, 42, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[3, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 9], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:28", "type":"resource", "data":[6, 1, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":28}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"2-bit Select", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"atax_10.c:29", "type":"resource", "data":[52, 82, 0, 1, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "children":[{"name":"32-bit Floating-point Multiply-Add", "type":"resource", "count":1, "data":[0, 0, 0, 1, 0]}, {"name":"Load", "type":"resource", "count":2, "data":[52, 82, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"6"}]}]}], "replace_name":"true"}]}]}, {"name":"atax.B8", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[73, 233, 0, 0, 5], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[73, 233, 0, 0, 5]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:38", "type":"resource", "data":[7, 2, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:29", "type":"resource", "data":[34, 24, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"9"}]}]}], "replace_name":"true"}, {"name":"atax_10.c:38", "type":"resource", "data":[26, 41, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[26, 41, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"9"}]}]}], "replace_name":"true"}]}]}, {"name":"atax.B9", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[33, 217, 0, 0, 6], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[33, 217, 0, 0, 6]}]}, {"name":"Feedback", "type":"resource", "data":[92, 221, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"atax_10.c:29", "type":"resource", "data":[8, 68, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]]}, {"name":"atax_10.c:35", "type":"resource", "data":[18, 16, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]]}, {"name":"atax_10.c:37", "type":"resource", "data":[31, 31, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":37}]]}, {"name":"atax_10.c:38", "type":"resource", "data":[33, 106, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]]}, {"name":"atax_10.c:5", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":5}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"atax_10.c:37", "type":"resource", "data":[6, 1, 0, 0, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":37}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"2-bit Select", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}, {"name":"5-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"atax_10.c:38", "type":"resource", "data":[182, 298, 0, 4, 0], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "children":[{"name":"32-bit Floating-point Multiply-Add", "type":"resource", "count":4, "data":[0, 0, 0, 4, 0]}, {"name":"Load", "type":"resource", "count":2, "data":[148, 274, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"6"}]}]}, {"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"atax_10.c", "line":"8"}]}]}], "replace_name":"true"}]}]}]}]};
var area_srcJSON={"children":[{"children":[{"data":[767,1766,0,0,29],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 192 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"192b wide with 0 elements.","type":"brief"}],"name":"Component call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Component return","type":"resource"},{"data":[131,505,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 and depth 1","type":"text"},{"text":"1 register of width 7 and depth 4 (depth was increased by a factor of 2 due to a loop initiation interval of 2.)","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"},{"text":"1 register of width 32 and depth 3","type":"text"},{"text":"1 register of width 32 and depth 4 (depth was increased by a factor of 2 due to a loop initiation interval of 2.)","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 7 width by 4 depth","type":"brief"}],"name":"Variable: \\n - \'i\' (atax_10.c:5)","type":"resource"},{"data":[52,248,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 and depth 4 (depth was increased by a factor of 4 due to a loop initiation interval of 4.)","type":"text"},{"text":"2 registers of width 32 and depth 1","type":"text"},{"text":"1 register of width 32 and depth 4 (depth was increased by a factor of 4 due to a loop initiation interval of 4.)","type":"text"},{"text":"Register,\\n1 reg, 7 width by 4 depth,\\n2 regs, 32 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'j\' (atax_10.c:5)","type":"resource"},{"data":[0,0,7,0,0],"details":[{"Additional information":[{"text":"Requested size 16384 bytes, implemented size 16384 bytes, stall-free, 2 reads and 2 writes. ","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"}],"Bank depth":"1024 words","Bank width":"128 bits","Implemented size":"16384 bytes","Memory Usage":"7 RAMs","Memory system":"Stall-free","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Requested size":"16384 bytes","type":"table"},{"text":"Stall-free,\\n16384B requested,\\n16384B implemented.","type":"brief"}],"name":"atax_10.c:6 (buff_A)","type":"resource"},{"data":[0,0,1,0,0],"details":[{"Additional information":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 1 read and 1 write. ","Bank depth":"64 words","Bank width":"32 bits","Implemented size":"256 bytes","Memory Usage":"1 RAM","Memory system":"Stall-free","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Requested size":"256 bytes","type":"table"},{"text":"Stall-free,\\n256B requested,\\n256B implemented.","type":"brief"}],"name":"atax_10.c:7 (buff_x)","type":"resource"},{"data":[0,0,0,0,8],"details":[{"Additional information":[{"text":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 2 reads and 2 writes. ","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"}],"Bank depth":"16 words","Bank width":"128 bits","Implemented size":"256 bytes","Memory Usage":"8 MLABs","Memory system":"Stall-free","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Requested size":"256 bytes","type":"table"},{"text":"Stall-free,\\n256B requested,\\n256B implemented.","type":"brief"}],"name":"atax_10.c:8 (buff_y_out)","type":"resource"},{"data":[33,256,1,0,0],"details":[{"Additional information":[{"text":"Requested size 256 bytes, implemented size 256 bytes, stall-free, 2 reads and 2 writes. ","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"}],"Bank depth":"64 words","Bank width":"32 bits","Clock":"Running memory at 2x clock to support more concurrent ports","Implemented size":"256 bytes","Memory Usage":"1 RAM","Memory system":"Stall-free","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Requested size":"256 bytes","type":"table"},{"text":"Stall-free,\\n256B requested,\\n256B implemented.","type":"brief"}],"name":"atax_10.c:9 (tmp1)","type":"resource"},{"children":[{"count":"1","data":[1,192,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"3"}]],"name":"State","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"3"}]],"name":"Stream Read","type":"resource"}],"data":[2,192,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":3}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:3","type":"resource"},{"children":[{"count":7,"data":[1096,2186,10,0,72],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[1096,2186,10,0,72],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"43"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"43"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"43"}]],"name":"4-bit Select","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"43"}]],"name":"5-bit Integer Compare","type":"resource"},{"count":1,"data":[12,10,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"43"}]],"name":"Iteration Initiation","type":"resource"}],"data":[20,11,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":43}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:43","replace_name":"true","type":"resource"},{"children":[{"count":3,"data":[3,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"44"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[74,137,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"44"}]],"name":"Load","type":"resource"},{"count":4,"data":[386,1106,0,0,20],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"44"}]],"name":"Store","type":"resource"}],"data":[463,1243,0,0,20],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":44}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:44","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"46"}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":46}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:46","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"13"}]],"name":"1-bit Xor","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"13"}]],"name":"7-bit Integer Compare","type":"resource"},{"count":1,"data":[9,7,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"13"}]],"name":"Iteration Initiation","type":"resource"}],"data":[12,8,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":13}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:13","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[251,221,0,0,7],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"14"}]],"name":"Load","type":"resource"},{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"14"}]],"name":"Store","type":"resource"}],"data":[285,245,0,0,7],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":14}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:14","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"15"}]],"name":"Store","type":"resource"}],"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":15}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:15","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"16"}]],"name":"Store","type":"resource"}],"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":16}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:16","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"18"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"18"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"18"}]],"name":"2-bit Select","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"18"}]],"name":"4-bit Integer Compare","type":"resource"}],"data":[5,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":18}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:18","replace_name":"true","type":"resource"},{"children":[{"count":8,"data":[2008,1768,0,0,56],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"19"}]],"name":"Load","type":"resource"},{"count":2,"data":[68,48,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"19"}]],"name":"Store","type":"resource"}],"data":[2076,1816,0,0,56],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":19}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:19","replace_name":"true","type":"resource"},{"children":[{"count":3,"data":[78,123,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"29"}]],"name":"Load","type":"resource"},{"count":1,"data":[0,0,0,1,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"29"}]],"name":"32-bit Floating-point Multiply-Add","type":"resource"},{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"29"}]],"name":"Store","type":"resource"}],"data":[112,147,0,1,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":29}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:29","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"35"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":35}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:35","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"28"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"28"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"28"}]],"name":"2-bit Select","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"28"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[6,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":28}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:28","replace_name":"true","type":"resource"},{"children":[{"count":3,"data":[174,315,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"38"}]],"name":"Load","type":"resource"},{"count":4,"data":[0,0,0,4,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"38"}]],"name":"32-bit Floating-point Multiply-Add","type":"resource"},{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"38"}]],"name":"Store","type":"resource"}],"data":[208,339,0,4,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":38}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:38","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"37"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"37"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"37"}]],"name":"2-bit Select","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":"37"}]],"name":"5-bit Integer Compare","type":"resource"}],"data":[6,1,0,0,0],"debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c","line":37}]],"name":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c:37","replace_name":"true","type":"resource"}],"compute_units":1,"data":[5347,9014,19,5,192],"debug":[[{"filename":"atax_10.c","line":5}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"atax","total_kernel_resources":[5347,9014,19,5,192],"total_percent":[7.90063,5.71829,2.8053,3.2368,2.60417],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[5347,9014,19,5,192],"debug_enabled":"true","max_resources":[160660,321320,587,192,8033],"name":"System","total":[5347,9014,19,5,192],"total_percent":[7.90063,5.71829,2.8053,3.2368,2.60417],"type":"module"};
var mavJSON={"nodes":[{"type":"component", "id":2, "name":"atax", "children":[{"type":"bb", "id":3, "name":"atax.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"atax.B1.start", "children":[{"type":"inst", "id":17, "name":"Stream Read", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":48, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"65"}]}, {"type":"inst", "id":49, "name":"End", "details":[{"type":"table", "Start Cycle":"2", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"2", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"atax.B2", "details":[{"type":"table", "Latency":"0"}]}, {"type":"bb", "id":6, "name":"atax.B3", "children":[{"type":"inst", "id":19, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":14}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"x", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":20, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":14}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"buff_x", "Start Cycle":"34", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":21, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":15}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"buff_y_out", "Start Cycle":"34", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":22, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":16}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"tmp1", "Start Cycle":"34", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":50, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"8"}]}, {"type":"inst", "id":51, "name":"End", "details":[{"type":"table", "Start Cycle":"35", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"35", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":7, "name":"atax.B4", "children":[{"type":"inst", "id":23, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":24, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":25, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":26, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":27, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":28, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":29, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":30, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":31, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"buff_A", "Start Cycle":"35", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":32, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":19}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"buff_A", "Start Cycle":"35", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":52, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":18}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"53"}]}, {"type":"inst", "id":53, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"39", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"39", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":8, "name":"atax.B5", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":9, "name":"atax.B6", "children":[{"type":"inst", "id":33, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"tmp1", "Start Cycle":"2", "Latency":"4", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":54, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"13"}]}, {"type":"inst", "id":55, "name":"End", "details":[{"type":"table", "Start Cycle":"10", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"10", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":10, "name":"atax.B7", "children":[{"type":"inst", "id":34, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"buff_A", "Start Cycle":"2", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":35, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"buff_x", "Start Cycle":"2", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":56, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":28}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"57"}]}, {"type":"inst", "id":57, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"13", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"13", "II":"4", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Loop is pipelined with II of 4. See Loops Analysis for more information."}]}, {"type":"bb", "id":11, "name":"atax.B8", "children":[{"type":"inst", "id":36, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":29}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"tmp1", "Start Cycle":"1", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":37, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"tmp1", "Start Cycle":"2", "Latency":"4", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":58, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":59, "name":"End", "details":[{"type":"table", "Start Cycle":"10", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"10"}]}, {"type":"bb", "id":12, "name":"atax.B9", "children":[{"type":"inst", "id":38, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"buff_y_out", "Start Cycle":"2", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":39, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"buff_A", "Start Cycle":"2", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":40, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":38}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"buff_y_out", "Start Cycle":"10", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":60, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":37}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"61"}]}, {"type":"inst", "id":61, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"14", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"14", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":13, "name":"atax.B10", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":14, "name":"atax.B11", "details":[{"type":"table", "Latency":"0"}]}, {"type":"bb", "id":15, "name":"atax.B12", "children":[{"type":"inst", "id":41, "name":"Load", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"buff_y_out", "Start Cycle":"3", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":42, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"y_out", "Start Cycle":"103", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":43, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"y_out", "Start Cycle":"72", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":44, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"y_out", "Start Cycle":"41", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":45, "name":"Store", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":44}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"y_out", "Start Cycle":"10", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":62, "name":"Loop Input", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":43}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"63"}]}, {"type":"inst", "id":63, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"134", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"134", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":16, "name":"atax.B13", "children":[{"type":"inst", "id":46, "name":"Stream Write", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":46}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":64, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":65, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"memtype", "id":69, "name":"Local Memory", "children":[{"type":"memsys", "id":70, "name":"buff_A", "debug":[[{"filename":"atax_10.c", "line":6}]], "details":[{"type":"table", "Requested size":"16384 bytes", "Implemented size":"16384 bytes", "Number of banks":"1", "Bank width":"128 bits", "Bank depth":"1024 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}, {"type":"memsys", "id":76, "name":"buff_x", "debug":[[{"filename":"atax_10.c", "line":7}]], "details":[{"type":"table", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Number of banks":"1", "Bank width":"32 bits", "Bank depth":"64 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}, {"type":"memsys", "id":80, "name":"buff_y_out", "debug":[[{"filename":"atax_10.c", "line":8}]], "details":[{"type":"table", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Number of banks":"1", "Bank width":"128 bits", "Bank depth":"16 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}, {"type":"memsys", "id":86, "name":"tmp1", "debug":[[{"filename":"atax_10.c", "line":9}]], "details":[{"type":"table", "Requested size":"256 bytes", "Implemented size":"256 bytes", "Number of banks":"1", "Bank width":"32 bits", "Bank depth":"64 words", "Number of replicates":"1", "Number of private copies":"1", "Additional Information":"Running memory at 2x clock to support more concurrent ports", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":92, "name":"0", "details":[{"type":"table", "Number of banks":"1", "Arguments from atax":"A, x, y_out"}]}]}, {"type":"stream", "id":18, "name":"call.atax", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Bits per symbol":"192 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":47, "name":"return.atax", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"interface", "id":66, "name":"A", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"atax"}]}, {"type":"interface", "id":67, "name":"x", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"atax"}]}, {"type":"interface", "id":68, "name":"y_out", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"atax"}]}], "links":[{"from":18, "to":17}, {"from":46, "to":47}, {"from":66, "to":17}, {"from":67, "to":17}, {"from":68, "to":17}, {"from":70, "to":34}, {"from":31, "to":70}, {"from":32, "to":70}, {"from":70, "to":39}, {"from":76, "to":35}, {"from":20, "to":76}, {"from":80, "to":38}, {"from":80, "to":41}, {"from":21, "to":80}, {"from":40, "to":80}, {"from":86, "to":33}, {"from":86, "to":37}, {"from":22, "to":86}, {"from":36, "to":86}, {"from":65, "to":48}, {"from":3, "to":48}, {"from":17, "to":49}, {"from":8, "to":5}, {"from":8, "to":50}, {"from":49, "to":50}, {"from":20, "to":51}, {"from":21, "to":51}, {"from":22, "to":51}, {"from":19, "to":51}, {"from":53, "to":52}, {"from":51, "to":52}, {"from":23, "to":53}, {"from":24, "to":53}, {"from":25, "to":53}, {"from":26, "to":53}, {"from":27, "to":53}, {"from":28, "to":53}, {"from":29, "to":53}, {"from":30, "to":53}, {"from":31, "to":53}, {"from":32, "to":53}, {"from":53, "to":8}, {"from":13, "to":54}, {"from":5, "to":54}, {"from":33, "to":55}, {"from":57, "to":56}, {"from":55, "to":56}, {"from":34, "to":57}, {"from":35, "to":57}, {"from":57, "to":58}, {"from":36, "to":59}, {"from":37, "to":59}, {"from":61, "to":60}, {"from":59, "to":60}, {"from":40, "to":61}, {"from":61, "to":13}, {"from":13, "to":14}, {"from":63, "to":62}, {"from":14, "to":62}, {"from":42, "to":63}, {"from":43, "to":63}, {"from":44, "to":63}, {"from":45, "to":63}, {"from":41, "to":63}, {"from":63, "to":64}, {"from":46, "to":65}, {"from":48, "to":17}, {"from":50, "to":19}, {"from":19, "to":20}, {"from":50, "to":21}, {"from":50, "to":22}, {"from":52, "to":23}, {"from":52, "to":24}, {"from":52, "to":25}, {"from":52, "to":26}, {"from":52, "to":27}, {"from":52, "to":28}, {"from":52, "to":29}, {"from":52, "to":30}, {"from":23, "to":31}, {"from":24, "to":31}, {"from":25, "to":31}, {"from":26, "to":31}, {"from":27, "to":31}, {"from":28, "to":31}, {"from":29, "to":31}, {"from":30, "to":31}, {"from":23, "to":32}, {"from":24, "to":32}, {"from":25, "to":32}, {"from":26, "to":32}, {"from":27, "to":32}, {"from":28, "to":32}, {"from":29, "to":32}, {"from":30, "to":32}, {"from":54, "to":33}, {"from":56, "to":34}, {"from":56, "to":35}, {"from":58, "to":36}, {"from":58, "to":37}, {"from":60, "to":38}, {"from":60, "to":39}, {"from":38, "to":40}, {"from":39, "to":40}, {"from":62, "to":41}, {"from":41, "to":42}, {"from":41, "to":43}, {"from":41, "to":44}, {"from":41, "to":45}, {"from":64, "to":46}, {"from":92, "to":24}, {"from":92, "to":27}, {"from":92, "to":30}, {"from":43, "to":92}, {"from":92, "to":19}, {"from":44, "to":92}, {"from":92, "to":28}, {"from":42, "to":92}, {"from":92, "to":25}, {"from":92, "to":26}, {"from":92, "to":29}, {"from":45, "to":92}, {"from":92, "to":23}]};
var loopsJSON={"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Component: atax", "data":["", "", ""], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"atax.B1.start", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: 1 is the default for component invocation loop"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"atax.B3", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"8X Partially unrolled atax.B4", "data":["Yes", "~1", "1"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":18}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"19"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}, {"name":"Fused loop atax.B6", "data":["Yes", ">=1", "0"], "debug":[[{"filename":"Multiple Locations", "line":0}]], "details":[{"type":"brief", "text":"Serial exe: Memory dependency"}, {"type":"text", "text":"Iteration executed serially across atax.B9. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"38"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"38"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"Fused subloop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"atax_10.c", "line":25}]], "children":[]}, {"name":"atax.B7", "data":["Yes", "4", "1"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":28}]], "details":[{"type":"text", "text":"Original parent is at line: 25"}, {"type":"brief", "text":"Data dependency"}, {"type":"text", "text":"Most critical loop feedback path during scheduling:", "details":[{"type":"text", "text":"4.00 clock cycles 32-bit Floating-point Multiply-Add Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"29"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Stallable instruction: None"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}, {"name":"Fused subloop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"atax_10.c", "line":35}]], "children":[]}, {"name":"4X Partially unrolled atax.B9", "data":["Yes", "1", "1"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":37}]], "details":[{"type":"text", "text":"Original parent is at line: 35"}, {"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Stallable instruction: None"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}, {"name":"4X Partially unrolled atax.B12", "data":["Yes", "~1", "3"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":43}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Additional dependency due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":"44"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}]}]};
var loop_attrJSON={"name":"loop_attributes", "id":4294967295, "nodes":[{"name":"atax", "id":1377166336, "clk":"Yes", "fmax":"100.00", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":4}]], "type":"component", "children":[{"name":"atax.B0.runOnce", "id":1379148752, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"1", "lt":"2.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "type":"bb"}, {"name":"atax.B1.start", "id":1376811664, "af":"100.00", "br":"0", "ci":"1", "ii":"1", "ll":"1", "lt":"2.000000", "mi":"1", "pl":"Yes", "tc":"0", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":4}]], "type":"loop", "children":[{"name":"atax.B3", "id":1381410672, "af":"100.00", "br":"0", "ci":"0", "ii":"2", "ll":"2", "lt":"35.000000", "mi":"1", "pl":"Yes", "tc":"0", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":13}]], "type":"loop", "children":[{"name":"8X Partially unrolled atax.B4", "id":1382009504, "af":"100.00", "br":"1", "ci":"0", "ii":"1", "ll":"3", "lt":"39.000000", "mi":"1", "pl":"Yes", "tc":"8", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":18}]], "type":"loop"}]}, {"name":"atax.B5", "id":1383460944, "af":"100.00", "br":"1", "ci":"0", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"64", "type":"bb"}, {"name":"atax.B2", "id":1381389520, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "type":"bb"}, {"name":"Fused loop atax.B6", "id":1383506848, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"2", "lt":"10.000000", "mi":"1", "pl":"Yes", "tc":"0", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":35}]], "type":"loop", "children":[{"name":"atax.B7", "id":1383834880, "af":"100.00", "br":"1", "ci":"0", "ii":"4", "ll":"3", "lt":"13.000000", "mi":"4", "pl":"Yes", "tc":"64", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":28}]], "type":"loop"}, {"name":"atax.B8", "id":1384694048, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"3", "lt":"10.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "type":"bb"}, {"name":"4X Partially unrolled atax.B9", "id":1384907360, "af":"100.00", "br":"1", "ci":"0", "ii":"1", "ll":"3", "lt":"14.000000", "mi":"1", "pl":"Yes", "tc":"16", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":37}]], "type":"loop"}]}, {"name":"atax.B10", "id":1385800832, "af":"100.00", "br":"1", "ci":"0", "ii":"1", "ll":"2", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"64", "type":"bb"}, {"name":"atax.B11", "id":1385889552, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "type":"bb"}, {"name":"4X Partially unrolled atax.B12", "id":1385911024, "af":"100.00", "br":"1", "ci":"0", "ii":"1", "ll":"2", "lt":"134.000000", "mi":"1", "pl":"Yes", "tc":"16", "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":43}]], "type":"loop"}]}, {"name":"atax.B13", "id":1387049424, "af":"100.00", "br":"0", "ci":"0", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "type":"bb"}]}]};
var summaryJSON={"functionNameMapping":{"name":"Synthesized Function Name Mapping", "columns":["User-defined Function Name", "Mapped Function Name"], "children":[{"name":"atax(float (*) [64], float*, float*)", "data":["atax"], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Function Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"atax", "data":[5347, 9014, 19, 5, 192], "debug":[[{"filename":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "line":3}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[5347, 9014, 19, 5, 192], "data_percent":[3.32815, 2.8053, 3.2368, 2.60417]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[160660, 321320, 587, 192, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}};
var warningsJSON={"nodes":[]};
var fileJSON=[{"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_function_traits.h", "name":"_function_traits.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_function_traits.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/*********************************************************************\012 *                                                                   *\012 *  Metaprogramming to extract the return type from a function type  *\012 *                                                                   *\012 *********************************************************************/\012#ifndef _INTEL_IHC_HLS_FUNCTION_TRAITS\012#define _INTEL_IHC_HLS_FUNCTION_TRAITS\012\012namespace ihc {\012  template<typename F>\012  struct function_traits {\012    using return_type = F;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(*)(Args...)>\012  {\012    using return_type = R;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(&)(Args...)>\012  {\012    using return_type = R;\012  };\012}\012\012#endif // _INTEL_IHC_HLS_FUNCTION_TRAITS\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_hls.h", "name":"_hls.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_hls.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/*****************************************************\012 *                                                   *\012 *  Internals of Basic Support for Intel's HLS Tool  *\012 *  DO NOT REFERENCE DIRECTLY                        *\012 *                                                   *\012 *****************************************************/\012\012#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef __INTELFPGA_COMPILER__\012   // Compiling for FPGA or x86 using FPGA compiler\012#  undef component\012#  define component __attribute__((ihc_component)) __attribute__((noinline))\012#else\012#  ifndef component\012#    define component\012#  endif\012#  ifndef HLS_X86\012#    define HLS_X86\012#  endif\012#endif\012\012#include <type_traits>\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#include <stdio.h>\012#include <stdlib.h>\012#ifdef _HLS_EMBEDDED_PROFILE\012#include \"HLS/internal/emulator_threadsupport.h\"\012#else\012#include <mutex>\012#include <condition_variable>\012#endif\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012#define __hls_mm_master_aspace(__x) __attribute__((address_space(__x + 1024)))\012#else\012#define __hls_mm_master_aspace(__x)\012#endif\012\012#ifdef _HLS_EMBEDDED_PROFILE\012#define _VIRTUAL_\012#else\012#define _VIRTUAL_ virtual\012#endif\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#if defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name, unsigned int wait_cycles);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012extern \"C\" void __ihc_hls_set_component_wait_cycle(const void * component_address, unsigned int num_wait_cycles);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012\012#ifdef HLS_X86\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012#ifndef _HLS_EMBEDDED_PROFILE\012  printf(\"Error: %s\\n\",msg);\012  assert(0);\012#endif\012}\012#endif\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012// ignore __fpga_reg in emulation flow\012#ifdef HLS_X86\012  #define __fpga_reg(x) (x)\012#elif defined(__clang__)\012#if __has_builtin(__builtin_fpga_reg)\012  #ifndef __fpga_reg\012    #define __fpga_reg __builtin_fpga_reg\012  #endif\012#endif\012#endif\012\012namespace ihc {\012\012template <template <int> class _Type, class _T>\012struct MatchType : std::is_same<_Type<_T::value>, _T> {};\012\012template <template <int> class _Type, class... _T> struct GetValue {\012  // any value is ok here, so '0' is fine for an arbitrary instantiation\012  enum { value = _Type<0>::defaultValue };\012  // only when _T is empty\012};\012\012template <template <int> class _Type, class _T1, class... _T>\012struct GetValue<_Type, _T1, _T...> {\012  enum {\012    value = std::conditional<MatchType<_Type, _T1>::value, _T1,\012                             GetValue<_Type, _T...>>::type::value\012  };\012};\012\012namespace internal {\012\012using namespace std;\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace;\012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  size_t sim_base;\012\012protected:\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012\012#endif\012public:\012#ifdef HLS_X86\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              int readwrite_mode, bool byteenabled, int maxburst, int align,\012              bool waitrequest, void *mem, size_t size, size_t data_size,\012              bool use_socket)\012      : aspace(aspace), awidth(awidth), dwidth(dwidth), latency(latency),\012        readwrite_mode(static_cast<readwrite_t>(readwrite_mode)),\012        byteenabled(byteenabled), maxburst(maxburst), align(align),\012        waitrequest(waitrequest), sim_base(0), data_size(data_size), mem(mem), size(size),\012        use_socket(use_socket)  {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              readwrite_t readwrite_mode, bool byteenabled, int maxburst,\012              int align, bool waitrequest);\012  // set_parameters, set_base, and get_sim_base are defined in the hls_cosim library\012  void set_parameters(int aspace, int awidth, int dwidth, int latency,\012                      readwrite_t readwrite_mode, bool byteenabled,\012                      int maxburst, int align, bool waitrequest);\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() const {return aspace;}\012  void * get_base() const {return mem;}\012  size_t get_size() const {return size;}\012  int get_awidth() const {return awidth;}\012  int get_dwidth() const {return dwidth;}\012  int get_latency() const {return latency;}\012  readwrite_t get_readwrite_mode() const {return readwrite_mode;}\012  bool get_byteenabled() const {return byteenabled;}\012  int get_maxburst() const {return maxburst;}\012  int get_align() const {return align;}\012  bool get_waitrequest() const {return waitrequest;}\012\012  size_t get_data_size() const {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base();\012\012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() const {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012#ifndef _HLS_EMBEDDED_PROFILE\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual size_t get_size() = 0;\012#endif\012};\012#endif\012\012template<typename T, class ... Params>\012class stream\012#ifdef HLS_X86\012  :  public stream_abstract_base\012#endif\012{\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012  std::queue<int> qpe_;\012  mutex m_;\012  condition_variable cv_;\012#endif\012public:\012  stream();\012  // do not allow copy and assignment of streams\012  stream(const stream&) = delete;\012  stream& operator=(const stream&) = delete;\012\012  bool _internal_cosim_empty();\012#ifdef HLS_X86\012  _VIRTUAL_ T read(bool wait=false);\012  _VIRTUAL_ void write(const T& arg);\012  _VIRTUAL_ T tryRead(bool &success);\012  _VIRTUAL_ bool tryWrite(const T& arg);\012\012  // for packet based stream\012  _VIRTUAL_ T read(bool& sop, bool& eop, bool wait=false);\012  _VIRTUAL_ T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  _VIRTUAL_ void write(const T& arg, bool sop, bool eop);\012  _VIRTUAL_ void write(const T& arg, bool sop, bool eop, int empty);\012  _VIRTUAL_ T tryRead(bool &success, bool& sop, bool& eop);\012  _VIRTUAL_ T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  _VIRTUAL_ bool tryWrite(const T& arg, bool sop, bool eop);\012  _VIRTUAL_ bool tryWrite(const T& arg, bool sop, bool eop, int empty);\012  _VIRTUAL_ void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  _VIRTUAL_ void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();\012  void write(const T& arg);\012  T tryRead(bool &success);\012  bool tryWrite(const T& arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  T read(bool& sop, bool& eop, int& empty);\012  void write(const T& arg, bool sop, bool eop);\012  void write(const T& arg, bool sop, bool eop, int empty);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const T& arg, bool sop, bool eop);\012  bool tryWrite(const T& arg, bool sop, bool eop, int empty);\012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012   T _internal_cosim_front(bool& sop, bool& eop, int& empty);\012\012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void write_by_ptr_pkt_e(void *data, bool* sop, bool*eop, void* empty);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, class ... Params>\012  stream<T,Params...>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, class ... Params>\012bool stream<T,Params...>::_internal_cosim_empty() {\012  bool empty=q_.empty();\012  return empty;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success) {\012  unique_lock<mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012\012    // unused sideband signals\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  unique_lock<mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  unique_lock<mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    empty = qpe_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool wait) {\012  unique_lock<mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this](){return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, bool wait) {\012  unique_lock<mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  // unused sideband signal\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  unique_lock<mutex> lock{ m_ };\012  bool empty_ = _internal_cosim_empty();\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty_ && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front() {\012  unique_lock<mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012  T arg = q_.front();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop) {\012  unique_lock<mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  T arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop, int& empty) {\012  unique_lock<mutex> _{ m_ };\012  bool empty_ = _internal_cosim_empty();\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  T arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012  return arg;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop, int empty) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop, empty);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg) {\012    {\012        unique_lock<mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(false,false));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop) {\012    {\012        unique_lock<mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop, int empty) {\012    {\012        unique_lock<mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(empty);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = read(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = _internal_cosim_front(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    T elem;\012    int temp_empty;\012    memcpy(&elem, data, sizeof(T));\012    memcpy(&temp_empty, empty, sizeof(int));\012    write(elem, *sop, *eop, temp_empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012bool stream<T, Params...>::stall() {\012  if (m_remaining_period == 0) {\012    setStallPeriod();\012  }\012  m_remaining_period--;\012  if (m_remaining_period < m_period_threshold) {\012    return false;\012  } else {\012    return true;\012  }\012}\012\012template<typename T, class ... Params>\012unsigned stream<T, Params...>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012\012  x *= x;\012  x += (w += s);\012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_memory.h", "name":"_memory.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_memory.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012#ifndef __IHC_MEMORY_H__\012#define __IHC_MEMORY_H__\012\012#include \"HLS/internal/_hls.h\"\012#include \"HLS/lsu.h\"\012#include <type_traits>\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(                                                              \\\012    disable : 4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable : 4505) // unreferenced local function has been removed\012#endif\012\012namespace ihc {\012\012////////////////////////////////\012/// memory master interface  ///\012////////////////////////////////\012\012template <int _N> struct dwidth {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 64;\012};\012\012template <int _N> struct awidth {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 64;\012};\012\012template <int _N> struct latency {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <int _N> struct readwrite_mode {\012  // Should be enum readwrite_t but we don't know how to make GetValue generic\012  static constexpr enum readwrite_t value = (readwrite_t)_N;\012  static constexpr enum readwrite_t defaultValue = readwrite;\012};\012\012template <int _N> struct maxburst {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <int _N> struct align {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = -1;\012};\012\012template <int _N> struct aspace {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <int _N> struct waitrequest {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = false;\012};\012\012template <typename _DT, int _dwidth, int _awidth, int _aspace, int _latency,\012          int _maxburst, int _align, int _readwrite_mode, int _waitrequest>\012class mm_master_checker {\012  static_assert(_aspace > 0, \"mm_master 'aspace' parameter must be at least 1\");\012};\012\012template <typename _DT, class... _Params>\012class mm_master final\012#ifdef HLS_X86\012    : public internal::memory_base\012#endif\012{\012public:\012#ifdef HLS_X86\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false)\012      : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                              _readwrite_mode, true, _maxburst, _align,\012                              _waitrequest, data, size, sizeof(_DT),\012                              use_socket) {\012    mSize = size;\012    mUse_socket = use_socket;\012    if (size > 0 && size % sizeof(_DT) != 0) {\012      __ihc_hls_runtime_error_x86(\012          \"The buffer size must be a multiple of the type size\");\012    }\012  }\012#else\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false);\012#endif\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // but illegal in a component\012  mm_master(const mm_master &other);\012\012  mm_master &operator=(const mm_master &other);\012\012  // Clean up any derived mm_masters when this object is destroyed.\012  ~mm_master();\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator _T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  _DT &operator[](int index);\012  _DT &operator*();\012  _DT *operator->();\012  template <typename _T> operator _T();\012  _DT *operator+(int index);\012  template <typename _T> _DT *operator&(_T value);\012  template <typename _T> _DT *operator|(_T value);\012  template <typename _T> _DT *operator^(_T value);\012  // This function is only supported in the testbench:\012  mm_master<_DT, _Params...> &getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012private:\012  std::vector<internal::memory_base *> new_masters;\012#else // Fpga\012\012#endif\012private:\012  static constexpr int _dwidth = ihc::GetValue<ihc::dwidth, _Params...>::value;\012  static constexpr int _awidth = ihc::GetValue<ihc::awidth, _Params...>::value;\012  static constexpr int _aspace = ihc::GetValue<ihc::aspace, _Params...>::value;\012  static constexpr int _latency = ihc::GetValue<ihc::latency, _Params...>::value;\012  static constexpr int _maxburst = ihc::GetValue<ihc::maxburst, _Params...>::value;\012  static constexpr int _align = (ihc::GetValue<ihc::align, _Params...>::value == -1)\012                                    ? alignof(_DT)\012                                    : ihc::GetValue<ihc::align, _Params...>::value;\012  static constexpr int _readwrite_mode =\012      ihc::GetValue<ihc::readwrite_mode, _Params...>::value;\012  static constexpr bool _waitrequest =\012      ihc::GetValue<ihc::waitrequest, _Params...>::value;\012  static constexpr mm_master_checker<_DT, _dwidth, _awidth, _aspace, _latency,\012                                     _maxburst, _align, _readwrite_mode,\012                                     _waitrequest>\012      checker{};\012  _DT __hls_mm_master_aspace(_aspace) * mPtr;\012  int mSize;\012  bool mUse_socket;\012};\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementations, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012#ifdef HLS_X86\012//////////////////\012/// mm_master  ///\012//////////////////\012\012// The copy constructor and assignment operator are needed in the testbench\012// necessary to ensure but illegal in a component\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::mm_master(const mm_master &other)\012    : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                            static_cast<readwrite_t>(_readwrite_mode), true,\012                            _maxburst, _align, _waitrequest, other.get_base(),\012                            other.get_size(), sizeof(_DT),\012                            other.uses_socket()) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.mUse_socket;\012  mem = other.mem;\012}\012\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...> &\012mm_master<_DT, _Params...>::operator=(const mm_master &other) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.m_Use_socket;\012  mem = other.mem;\012}\012\012// Clean up any derived mm_masters when this object is destroyed.\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::~mm_master() {\012  for (std::vector<internal::memory_base *>::iterator it = new_masters.begin(),\012                                                      ie = new_masters.end();\012       it != ie; it++) {\012    delete *it;\012  }\012  new_masters.clear();\012}\012\012template <typename _DT, class... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  assert(size == 0 || index * data_size < size);\012  return ((_DT *)mem)[index];\012}\012\012template <typename _DT, class... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return ((_DT *)mem)[0];\012}\012\012template <typename _DT, class... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT *)mem;\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)mem);\012}\012\012template <typename _DT, class... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  assert(size == 0 || index * data_size < size);\012  return &((_DT *)mem)[index];\012}\012\012// Bitwise operators\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT *)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT *)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT *)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...> &\012mm_master<_DT, _Params...>::getInterfaceAtIndex(int index) {\012  assert(mSize == 0 || index * data_size < mSize);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<_DT, _Params...> *temp = new mm_master(\012      &(((_DT *)mem)[index]), mSize - index * sizeof(_DT), mUse_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012#else // fpga path. Ignore the class just return a consistent pointer/reference\012\012//////////////////\012/// mm_master  ///\012//////////////////\012template <typename _DT, class... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  return *(_DT *)__builtin_intel_hls_mm_master_load(\012      mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst,\012      _align, _readwrite_mode, _waitrequest, index);\012}\012\012template <typename _DT, class... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return *(_DT *)__builtin_intel_hls_mm_master_load(\012      mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst,\012      _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT *)__builtin_intel_hls_mm_master_load(\012      mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst,\012      _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  return (_DT *)__builtin_intel_hls_mm_master_load(\012             mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency,\012             _maxburst, _align, _readwrite_mode, _waitrequest, (int)0) +\012         index;\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)__builtin_intel_hls_mm_master_load(\012      mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst,\012      _align, _readwrite_mode, _waitrequest, (int)0));\012}\012\012// Bitwise operators\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (\012      _DT *)(((unsigned long long)__builtin_intel_hls_mm_master_load(\012                 mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency,\012                 _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) &\012             (unsigned long long)value);\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (\012      _DT *)(((unsigned long long)__builtin_intel_hls_mm_master_load(\012                 mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency,\012                 _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) |\012             (unsigned long long)value);\012}\012\012template <typename _DT, class... _Params>\012template <typename _T>\012_DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (\012      _DT *)(((unsigned long long)__builtin_intel_hls_mm_master_load(\012                 mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency,\012                 _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) ^\012             (unsigned long long)value);\012}\012\012#endif // HLS_X86\012} // namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif //  __IHC_MEMORY_H__\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_pipes.h", "name":"_pipes.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_pipes.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012#ifndef __HLS_INTERNAL_PIPES__\012#define __HLS_INTERNAL_PIPES__\012\012namespace ihc {\012namespace internal {\012\012// Struct representing layout of pipe storage\012struct ConstantPipeStorage {\012  int  _PacketSize;\012  int  _PacketAlignment;\012  int  _Capacity;\012};\012\012#ifdef HLS_X86\012template <typename T>\012extern void HLS_CreatePipeFromPipeStorage_read(\012    const ConstantPipeStorage *Storage) noexcept {};\012\012template <typename T>\012extern void HLS_CreatePipeFromPipeStorage_write(\012    const ConstantPipeStorage *Storage) noexcept {};\012\012#else // FPGA\012// Pipe types\012template<typename T>\012using RPipe = __attribute__((pipe(\"read_only\"))) const T;\012\012template<typename T>\012using WPipe = __attribute__((pipe(\"write_only\"))) const T;\012\012template <typename T>\012extern RPipe<T> HLS_CreatePipeFromPipeStorage_read(\012    const ConstantPipeStorage *Storage) noexcept;\012\012template <typename T>\012extern WPipe<T> HLS_CreatePipeFromPipeStorage_write(\012    const ConstantPipeStorage *Storage) noexcept;\012#endif\012\012} // namespace internal\012} // namespace ihc\012#endif // __HLS_INTERNAL_PIPES__\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_stream.h", "name":"_stream.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_stream.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012#ifndef __IHC_STREAM_H__\012#define __IHC_STREAM_H__\012\012#include \"HLS/internal/_hls.h\"\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(                                                              \\\012    disable : 4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable : 4505) // unreferenced local function has been removed\012#endif\012\012namespace ihc {\012/////////////////////////////\012/// streaming interfaces  ///\012/////////////////////////////\012\012template <int _N> struct buffer {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 0;\012};\012\012template <int _N> struct readyLatency {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 0;\012};\012\012template <int _N> struct bitsPerSymbol {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 0;\012};\012\012template <int _N> struct usesPackets {\012  static constexpr bool value = _N;\012  static constexpr bool defaultValue = false;\012};\012\012template <int _N> struct usesValid {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = true;\012};\012\012template <int _N> struct usesReady {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = true;\012};\012\012template <int _N> struct usesEmpty {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = false;\012};\012\012template <int _N> struct firstSymbolInHighOrderBits {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = false;\012};\012\012/////////////////////////\012/// Assert and Checks ///\012/////////////////////////\012template <typename _T, int _buffer, int _readyLatency, int _bitsPerSymbol,\012          int _firstSymbolInHighOrderBits, int _usesPackets, int _usesEmpty,\012          int _usesValid, int _usesReady>\012class stream_checker {\012private:\012  static_assert((_bitsPerSymbol > 0 && _bitsPerSymbol < 8 * sizeof(_T)) ||\012                    !_usesEmpty,\012                \"Stream parameter bitsPerSymbol must be set to a value \"\012                \"strictly grater than 0 and strictly smaller than the width of \"\012                \"the stream data bus when usesEmpty is set to true\");\012\012public:\012  void checkUsesPackets() const {\012    static_assert(_usesPackets,\012                  \"Using startofpacket and endofpacket requires a stream \"\012                  \"with the parameterization: usesPackets<true>\");\012  }\012\012  void checkUsesEmpty() const {\012    static_assert(_usesEmpty,\012                  \"Empty based stream operations require a stream with the \"\012                  \"parameterization: usesEmpty<true>\");\012  }\012\012  void checkIfUsesEmptyThenUsesPackets() const {\012    static_assert(_usesPackets || !_usesEmpty,\012                  \"Empty based stream operations require a stream with the \"\012                  \"parametrizations: \"\012                  \"usesPackets<true>, usesEmpty<true>\");\012  }\012};\012\012/////////////////////////\012/// Class Definitions ///\012/////////////////////////\012template <typename _T, class... _Params>\012class stream_in final : public internal::stream<_T, _Params...> {\012public:\012  stream_in();\012  stream_in(const stream_in &) = delete;\012  stream_in(const stream_in &&) = delete;\012  stream_in &operator=(const stream_in &) = delete;\012  stream_in &operator=(const stream_in &&) = delete;\012  _T read(bool wait = false);\012  void write(const _T &arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T &arg);\012\012  // for packet based stream\012  _T read(bool &sop, bool &eop, bool wait = false);\012  _T read(bool &sop, bool &eop, int &empty, bool wait = false);\012  void write(const _T &arg, bool sop, bool eop);\012  void write(const _T &arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool &sop, bool &eop);\012  _T tryRead(bool &success, bool &sop, bool &eop, int &empty);\012  bool tryWrite(const _T &arg, bool sop, bool eop);\012  bool tryWrite(const _T &arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta = 0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta = 0);\012\012private:\012  static constexpr int _buffer = ihc::GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency =\012      ihc::GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol =\012      ihc::GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits =\012      ihc::GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets =\012      ihc::GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty =\012      ihc::GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid =\012      ihc::GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady =\012      ihc::GetValue<ihc::usesReady, _Params...>::value;\012  static constexpr stream_checker<_T, _buffer, _readyLatency, _bitsPerSymbol,\012                                  _firstSymbolInHighOrderBits, _usesPackets,\012                                  _usesEmpty, _usesValid, _usesReady>\012      checker{};\012};\012\012template <typename _T, class... _Params>\012class stream_out final : public internal::stream<_T, _Params...> {\012\012public:\012  stream_out();\012  stream_out(const stream_out &) = delete;\012  stream_out(const stream_out &&) = delete;\012  stream_out &operator=(const stream_out &) = delete;\012  stream_out &operator=(const stream_out &&) = delete;\012  _T read(bool wait = false);\012  void write(const _T &arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T &arg);\012\012  // for packet based stream\012  _T read(bool &sop, bool &eop, bool wait = false);\012  _T read(bool &sop, bool &eop, int &empty, bool wait = false);\012  void write(const _T &arg, bool sop, bool eop);\012  void write(const _T &arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool &sop, bool &eop);\012  _T tryRead(bool &success, bool &sop, bool &eop, int &empty);\012  bool tryWrite(const _T &arg, bool sop, bool eop);\012  bool tryWrite(const _T &arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta = 0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta = 0);\012\012private:\012  static constexpr int _buffer = ihc::GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency =\012      ihc::GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol =\012      ihc::GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits =\012      ihc::GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets =\012      ihc::GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty =\012      ihc::GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid =\012      ihc::GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady =\012      ihc::GetValue<ihc::usesReady, _Params...>::value;\012  static constexpr stream_checker<_T, _buffer, _readyLatency, _bitsPerSymbol,\012                                  _firstSymbolInHighOrderBits, _usesPackets,\012                                  _usesEmpty, _usesValid, _usesReady>\012      checker{};\012};\012\012// Bi-directional inter-task stream\012template <typename _T, class... _Params>\012class stream final : public internal::stream<_T, _Params...> {\012public:\012  stream();\012  stream(const stream &) = delete;\012  stream(const stream &&) = delete;\012  stream &operator=(const stream &) = delete;\012  stream &operator=(const stream &&) = delete;\012  _T read(bool wait = true);\012  void write(const _T &arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T &arg);\012\012  // for packet based stream\012  _T read(bool &sop, bool &eop, bool wait = true);\012  _T read(bool &sop, bool &eop, int &empty, bool wait = true);\012  void write(const _T &arg, bool sop, bool eop);\012  void write(const _T &arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool &sop, bool &eop);\012  _T tryRead(bool &success, bool &sop, bool &eop, int &empty);\012  bool tryWrite(const _T &arg, bool sop, bool eop);\012  bool tryWrite(const _T &arg, bool sop, bool eop, int empty);\012\012private:\012  static constexpr int _buffer = ihc::GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency =\012      ihc::GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol =\012      ihc::GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits =\012      ihc::GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets =\012      ihc::GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty =\012      ihc::GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid =\012      ihc::GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady =\012      ihc::GetValue<ihc::usesReady, _Params...>::value;\012  static_assert(_usesValid,\012                \"Bi-directional stream interfaces must use Valid signal\");\012  static_assert(_usesReady,\012                \"Bi-directional stream interfaces must use Ready signal\");\012  static constexpr stream_checker<_T, _buffer, _readyLatency, _bitsPerSymbol,\012                                  _firstSymbolInHighOrderBits, _usesPackets,\012                                  _usesEmpty, _usesValid, _usesReady>\012      checker{};\012};\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementations, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012#ifdef HLS_X86\012\012///////////////////\012/// stream_in   ///\012///////////////////\012\012template <typename _T, class... _Params>\012stream_in<_T, _Params...>::stream_in() {}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T, _Params...>::tryRead(success);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg) {\012  internal::stream<_T, _Params...>::write(arg);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                      int &empty) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool &sop, bool &eop, bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool &sop, bool &eop, int &empty,\012                                   bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, empty, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                         int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                      int empty) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::setStallCycles(unsigned average_stall,\012                                               unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be \"\012                                \"larger than the average stall value\");\012  }\012  internal::stream<_T, _Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::setValidCycles(unsigned average_valid,\012                                               unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\012        \"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be \"\012                                \"larger than the average valid value\");\012  }\012  internal::stream<_T, _Params...>::setReadyorValidCycles(average_valid,\012                                                          valid_delta);\012}\012\012///////////////////\012/// stream_out  ///\012///////////////////\012\012template <typename _T, class... _Params>\012stream_out<_T, _Params...>::stream_out() {}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T, _Params...>::tryRead(success);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg) {\012  internal::stream<_T, _Params...>::write(arg);\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                       int &empty) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool &sop, bool &eop,\012                                    bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool &sop, bool &eop, int &empty,\012                                    bool wait /*=false*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, empty, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop);\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                       int empty) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                          int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::setStallCycles(unsigned average_stall,\012                                                unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be \"\012                                \"larger than the average stall value\");\012  }\012  internal::stream<_T, _Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::setReadyCycles(unsigned average_ready,\012                                                unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\012        \"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be \"\012                                \"larger than the average ready value\");\012  }\012  internal::stream<_T, _Params...>::setReadyorValidCycles(average_ready,\012                                                          ready_delta);\012}\012\012///////////////////\012///// stream  /////\012///////////////////\012\012template <typename _T, class... _Params> stream<_T, _Params...>::stream() {}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T, _Params...>::tryRead(success);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool wait /*=true*/) {\012  _T elem = internal::stream<_T, _Params...>::read(wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg) {\012  internal::stream<_T, _Params...>::write(arg);\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                   int &empty) {\012  return internal::stream<_T, _Params...>::tryRead(success, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool &sop, bool &eop, bool wait /*=true*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool &sop, bool &eop, int &empty,\012                                bool wait /*=true*/) {\012  _T elem = internal::stream<_T, _Params...>::read(sop, eop, empty, wait);\012  return elem;\012}\012\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop);\012}\012\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                   int empty) {\012  internal::stream<_T, _Params...>::write(arg, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                      int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012#else // fpga path. Ignore the class just return a consistent pointer/reference\012\012///////////////////\012/// stream_in   ///\012///////////////////\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &emp, &success);\012}\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool wait) {\012  (void)wait;\012  checker.checkIfUsesEmptyThenUsesPackets();\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &emp);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg) {\012  __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer,\012                                     _readyLatency, _bitsPerSymbol,\012                                     _firstSymbolInHighOrderBits, _usesPackets,\012                                     _usesEmpty, _usesValid, false, false, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg) {\012  return __builtin_intel_hls_instream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false,\012      false, 0);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  checker.checkUsesPackets();\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &emp, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                      int &empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &empty, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool &sop, bool &eop, bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &emp);\012}\012template <typename _T, class... _Params>\012_T stream_in<_T, _Params...>::read(bool &sop, bool &eop, int &empty,\012                                   bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop,\012      &eop, &empty);\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  return __builtin_intel_hls_instream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop,\012      eop, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream_in<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                         int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return __builtin_intel_hls_instream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop,\012      eop, empty);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer,\012                                     _readyLatency, _bitsPerSymbol,\012                                     _firstSymbolInHighOrderBits, _usesPackets,\012                                     _usesEmpty, _usesValid, sop, eop, 0);\012}\012\012template <typename _T, class... _Params>\012void stream_in<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                      int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer,\012                                     _readyLatency, _bitsPerSymbol,\012                                     _firstSymbolInHighOrderBits, _usesPackets,\012                                     _usesEmpty, _usesValid, sop, eop, empty);\012}\012\012///////////////////\012/// stream_out  ///\012///////////////////\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp, &success);\012}\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp);\012}\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, false, false, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false,\012      false, 0);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                       int &empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return *__builtin_intel_hls_outstream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &empty, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool &sop, bool &eop, bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  int emp;\012  return *__builtin_intel_hls_outstream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp);\012}\012\012template <typename _T, class... _Params>\012_T stream_out<_T, _Params...>::read(bool &sop, bool &eop, int &empty,\012                                    bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return *__builtin_intel_hls_outstream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &empty);\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template <typename _T, class... _Params>\012void stream_out<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                       int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop,\012      eop, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream_out<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                          int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop,\012      eop, empty);\012}\012\012///////////////////\012///// stream  /////\012///////////////////\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp, &success);\012}\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp);\012}\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, false, false, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg) {\012  checker.checkIfUsesEmptyThenUsesPackets();\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false,\012      false, 0);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop) {\012  checker.checkUsesPackets();\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::tryRead(bool &success, bool &sop, bool &eop,\012                                   int &empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return *__builtin_intel_hls_instream_tryRead(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &empty, &success);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool &sop, bool &eop, bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  int emp;\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &emp);\012}\012\012template <typename _T, class... _Params>\012_T stream<_T, _Params...>::read(bool &sop, bool &eop, int &empty, bool wait) {\012  (void)wait;\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return *__builtin_intel_hls_instream_read(\012      (_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop,\012      &eop, &empty);\012}\012\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template <typename _T, class... _Params>\012void stream<_T, _Params...>::write(const _T &arg, bool sop, bool eop,\012                                   int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer,\012                                      _readyLatency, _bitsPerSymbol,\012                                      _firstSymbolInHighOrderBits, _usesPackets,\012                                      _usesEmpty, _usesReady, sop, eop, empty);\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop) {\012  checker.checkUsesPackets();\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop,\012      eop, 0);\012}\012\012template <typename _T, class... _Params>\012bool stream<_T, _Params...>::tryWrite(const _T &arg, bool sop, bool eop,\012                                      int empty) {\012  checker.checkUsesPackets();\012  checker.checkUsesEmpty();\012  return __builtin_intel_hls_outstream_tryWrite(\012      &arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol,\012      _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop,\012      eop, empty);\012}\012\012#endif // HLS_X86\012} // namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif // __IHC_STREAM_H__\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_task.h", "name":"_task.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_task.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/********************************************************\012 *                                                      *\012 *  Asynchronous Execution Support for System of Tasks  *\012 *                                                      *\012 ********************************************************/\012\012#ifndef _INTEL_IHC_HLS_TASK\012#define _INTEL_IHC_HLS_TASK\012\012#include \"HLS/internal/_hls.h\"\012#include \"HLS/internal/_function_traits.h\"\012\012#include <type_traits>\012#include <utility>\012\012// Make sure the macros to take the user calls into implementations\012// is not in effect for the source code of the implementation\012#undef launch\012#undef collect\012\012// Bring in the platform specific '_task' for composition\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012#include \"HLS/internal/_task_FPGA.h\"\012#else\012#include \"HLS/internal/_task_X86-64.h\"\012#endif\012\012namespace ihc {\012  namespace internal {\012    // Signature for void func()\012    using VoidFuncTy = void ();\012\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Launch the calculations\012    //   task<function>::launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    //\012    // The task is implemented as an\012    // Adaptor Design Pattern\012    // The X86-64 or FPGA implementation is adapted to the desired API\012    // This adaptor is straight forward:\012    // Both architecture specific implementations are supposed to\012    // be interface compatible with this adaptor\012    template<auto& f, bool detach = false>\012    class task {\012    public:\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Launch the callable\012      template<int capacity, typename ... Args>\012      static void launch(Args&& ... args) {\012        _t.template launch<capacity>(std::forward<Args>(args)...);\012      }\012\012      // Get the result\012      template<int capacity>\012      static T collect() {\012        // Restore void if needed\012        return static_cast<T>(_t.template collect<capacity>());\012      }\012\012    private:\012      // Constructor\012      task() {};\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      // Composition (_task is architecture specific)\012      // Singleton\012      // Anywhere in the function hierarchy where \"f\" gets called,\012      // this specific task (with the corresponding thread and queue)\012      // needs to be used\012      static internal::_task<f, detach> _t;\012    }; // class task\012\012    template <auto& f, bool detach>\012    internal::_task<f, detach> task<f, detach>::_t;\012\012\012    // launch_always_run_helper utilities\012    template <VoidFuncTy &f> void launch_always_run() {\012      while (1) {\012        f();\012      }\012    }\012\012    template <VoidFuncTy &f> class launch_always_run_helper {\012    public:\012      launch_always_run_helper() {\012        task<launch_always_run<f>, true>::template launch<0>();\012      }\012    };\012  } // namespace internal\012\012  // Launch (through singleton)\012  template <auto &f, int capacity = 0, typename... Args>\012  void launch(Args &&... args) {\012    internal::task<f>::template launch<capacity>(std::forward<Args>(args)...);\012  }\012\012  // Collect (through singleton)\012  template <auto &f, int capacity = 0>\012  typename ihc::function_traits<decltype(f)>::return_type collect() {\012    using T = typename ihc::function_traits<decltype(f)>::return_type;\012    // Restore void if needed\012    return static_cast<T>(internal::task<f>::template collect<capacity>());\012  }\012\012  /// Launches a task function at when the component starts up.\012  /// The task function to be launched must take no input arguments and have\012  /// a void return.\012  template <internal::VoidFuncTy &f> void launch_always_run() {\012    static internal::launch_always_run_helper<f> t;\012  }\012\012} // namespace ihc\012\012// For backwards compatibility\012#define launch(x, ...)  launch <x, 0>(__VA_ARGS__)\012#define collect(x)      collect<x, 0>()\012\012#endif // _INTEL_IHC_HLS_TASK\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_task_FPGA.h", "name":"_task_FPGA.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/internal/_task_FPGA.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/*********************************************************************\012 *                                                                   *\012 *  Internals of Asynchronous Execution Support for System of Tasks  *\012 *  DO NOT REFERENCE DIRECTLY                                        *\012 *                                                                   *\012 *********************************************************************/\012\012#ifndef _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#define _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#include \"HLS/internal/_function_traits.h\"\012\012namespace ihc {\012  namespace internal {\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Identify the functionality\012    //   task<function>::instance()\012    // * Launch the calculations\012    //   task<function>::instance().launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::instance().collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    template<auto& f, bool detach = false>\012    class _task {\012    public:\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Constructor\012      _task() {}\012\012      // Disable copy-assignment operator\012      _task& operator=(const _task& rhs) = delete;\012\012      // Disable copy constructor\012      _task(const _task& other) = delete;\012\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      template<int capacity, typename ... Args>\012      void launch(Args&&... args) {\012        __builtin_intel_hls_enqueue(capacity, f, std::forward<Args>(args)...);\012      } // launch\012\012      template<int capacity>\012      T collect() {\012        return static_cast<T>(__builtin_intel_hls_get(capacity, f));\012      }\012\012    }; // class _task\012\012  } //namespace internal\012} // namespace ihc\012\012#endif // _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012"}, {"path":"/home/slowe8/HLSDataset/polybench/atax/src/atax.h", "name":"atax.h", "has_active_debug_locs":false, "absName":"/home/slowe8/HLSDataset/polybench/atax/src/atax.h", "content":"#ifndef _LU_H\012#define _LU_H\012\012#include <HLS/stdio.h>\012#include <unistd.h>\012#include <string.h>\012#include <math.h>\012#include <HLS/hls.h>\012\012\012#define N 64\012\012#define DATA_TYPE float\012#define SCALAR_VAL(x) x##f\012#define SQRT_FUN(x) sqrtf(x)\012#define EXP_FUN(x) expf(x)\012#define POW_FUN(x,y) powf(x,y)\012\012void atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N]);\012\012#endif /* !_LU_H */\012"}, {"path":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "name":"atax_10.c", "has_active_debug_locs":false, "absName":"/home/slowe8/HLSDataset/polybench/atax/src/atax_10.c", "content":"#include \"atax.h\"\012\012component void atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N])\012{\012	int i, j;\012	DATA_TYPE buff_A[N][N];\012    	DATA_TYPE buff_x[N];\012    	DATA_TYPE buff_y_out[N];\012    	DATA_TYPE tmp1[N];\012\012	\012\012    	for (i = 0; i < N; i++) {\012        	buff_x[i] = x[i];\012    		buff_y_out[i] = 0;\012        	tmp1[i] = 0;\012		#pragma unroll 8\012    		for (j = 0; j < N; j++) {\012    			buff_A[i][j] = A[i][j];\012    		}\012    	}\012\012	\012\012    	for (i = 0; i < N; i++) {\012		\012\012        	for (j = 0; j < N; j++) {\012	        	tmp1[i] = tmp1[i] + buff_A[i][j] * buff_x[j];\012        	}\012    	}\012\012	\012\012	for (i = 0; i < N; i++) {\012        	#pragma unroll 4\012		for (j = 0; j < N; j++) {\012        		buff_y_out[j] = buff_y_out[j] + buff_A[i][j] * tmp1[i];\012        	}\012    	}\012\012	#pragma unroll 4\012    	for (i = 0; i < N; i++) {\012        	y_out[i] = buff_y_out[i];\012    	}\012}"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/hls.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/*********************************************\012 *                                           *\012 *  Basic Support for Intel's HLS Tool       *\012 *                                           *\012 *********************************************/\012#ifndef __HLS_H__\012#define __HLS_H__\012\012#include \"HLS/internal/_stream.h\"\012#include \"HLS/internal/_memory.h\"\012#include \"HLS/internal/_task.h\"\012#include \"HLS/internal/_hls.h\"\012#include \"HLS/pipes.h\"\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_memory_impl(__x)                          __attribute__((__memory__(__x)))\012#define hls_force_pow2_depth(__x)                        __attribute__((__force_pow2_depth__(__x)))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_simple_dual_port_memory                   __attribute__((simple_dual_port))\012#define hls_max_replicates(__x)                       __attribute__((max_replicates(__x)))\012#define hls_private_copies(__x)                   __attribute__((__private_copies__(__x)))\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012#define hls_readonly                          __attribute__((readwrite_mode(\"readonly\")))\012#define hls_writeonly                         __attribute__((readwrite_mode(\"writeonly\")))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012#define hls_scheduler_target_fmax_mhz(__x)     __attribute__((scheduler_target_fmax_mhz(__x)))\012#define hls_component_ii(__x)                  __attribute__((hls_ii(__x)))\012#define hls_disable_component_pipelining       __attribute__((hls_force_loop_pipelining(\"off\")))\012\012// Cluster attributes\012#define hls_use_stall_enable_clusters          __attribute__((stall_enable))\012\012// fpga_reg support\012#define hls_fpga_reg(__x)                      __fpga_reg(__x)\012\012#else // __INTELFPGA_COMPILER__\012#define hls_register\012#define hls_memory\012#define hls_memory_impl(__x)\012#define hls_force_pow2_depth(__x)\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_simple_dual_port_memory\012#define hls_max_replicates(__x)\012#define hls_private_copies(__x)\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012#define hls_writeonly\012#define hls_readonly\012\012#define hls_max_concurrency(__x)\012#define hls_scheduler_target_fmax_mhz(__x)\012#define hls_component_ii(__x)\012#define hls_disable_component_pipelining\012\012#define hls_use_stall_enable_clusters\012\012#define hls_fpga_reg(__x) __x\012#endif // __INTELFPGA_COMPILER__\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...)\\\012  {\\\012    if (__ihc_hls_async_call_capable()){\\\012      __ihc_enqueue_handle=(retptr);\\\012      (void) (*(func))(__VA_ARGS__);\\\012      __ihc_enqueue_handle=0;\\\012    } else {\\\012      *(retptr) = (*(func))(__VA_ARGS__);\\\012    }\\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...)\\\012  {\\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle;\\\012  (*(func))(__VA_ARGS__);\\\012  __ihc_enqueue_handle=0;\\\012  }\012\012#define ihc_hls_component_run_all(component_address)\\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012#define ihc_hls_set_component_wait_cycle(component_address, num_wait_cycles)\\\012  __ihc_hls_set_component_wait_cycle((void*) (component_address), num_wait_cycles)\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occurred (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {}\012\012#else\012extern \"C\" void __acl_mem_fence(unsigned int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  __acl_mem_fence(-1);\012}\012#endif\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/lsu.h", "name":"lsu.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/lsu.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012/**************************************************************************\012 *                                                                        *\012 *  A library that allows controlling the LSU of a given load/store site  *\012 *                                                                        *\012 *  Author: Mohammad Fawaz                                                *\012 *                                                                        *\012 **************************************************************************/\012\012#ifndef __HLS_LSU_H__\012#define __HLS_LSU_H__\012\012namespace ihc {\012// Forward declarations. These are defined in HLS/hls.h\012template <typename _DT, class... _Params> class mm_master;\012template <template <int> class _Type, class... _T> struct GetValue;\012\012enum style_t {\012  BURST_COALESCED = 0,\012  PIPELINED,\012  PREFETCHING,\012};\012\012template <int _N> struct style {\012  static constexpr enum style_t value = (style_t)_N;\012  static constexpr enum style_t defaultValue = BURST_COALESCED;\012};\012\012template <int _N> struct static_coalescing {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <class... _LSUParams> class lsu final {\012public:\012  lsu() = delete;\012\012#ifdef HLS_X86\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    return *Ptr;\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) { return *Ptr; }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    *Ptr = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) { *Ptr = Val; }\012#else\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0,\012                               _style == PREFETCHING, 0, 0, _static_coalescing);\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0,\012                               _style == PREFETCHING, 0, 0, _static_coalescing);\012  }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(&*Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012#endif\012\012private:\012  static constexpr int _style = GetValue<ihc::style, _LSUParams...>::value;\012  static constexpr int _static_coalescing =\012      GetValue<ihc::static_coalescing, _LSUParams...>::value;\012\012  static void CheckLoad() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED ||\012                      _style == PREFETCHING,\012                  \"Invalid LSU style choice for a load operation\");\012  }\012  static void CheckStore() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED,\012                  \"Invalid LSU style choice for a store operation\");\012  }\012};\012} // namespace ihc\012\012#endif //__HLS_LSU_H__\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/pipes.h", "name":"pipes.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/pipes.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012#ifndef __HLS_PIPES__\012#define __HLS_PIPES__\012\012#ifdef CL_SYCL_LANGUAGE_VERSION\012// Defer to SYCL pipes implementation\012#include \"CL/sycl/pipes.hpp\"\012namespace ihc {\012template<class name, class T, unsigned capacity = 0>\012using pipe = cl::sycl::pipe<name, T, capacity>;\012}\012#else // HLS\012\012#include \"HLS/internal/_hls.h\"\012#include \"HLS/internal/_pipes.h\"\012\012namespace ihc {\012\012template<class name, class T, unsigned capacity = 0>\012class pipe {\012public:\012  // Non-blocking\012  static T read(bool &success);\012  static void write(const T &data, bool &success);\012  // Blocking\012  static T read();\012  static void write(const T &data);\012\012private:\012  static constexpr int _size = sizeof(T);\012  static constexpr int _alignment = alignof(T);\012  static constexpr int _capacity = capacity;\012  static constexpr internal::ConstantPipeStorage _storage = {_size, _alignment,\012                                                             _capacity};\012#ifdef HLS_X86\012private:\012  static internal::stream<T> _stream;\012#endif\012};\012\012#ifdef HLS_X86\012template<class name, class T, unsigned capacity>\012internal::stream<T> pipe<name, T, capacity>::_stream;\012\012template<class name, class T, unsigned capacity>\012T pipe<name, T, capacity>::read(bool &success) {\012  // Need to call dummy function CreatePipeFromPipeStorage\012  // so _storage object is visible to ReplaceComponentHLSSim pass.\012  internal::HLS_CreatePipeFromPipeStorage_read<T>(&_storage);\012  return _stream.tryRead(success);\012}\012\012template<class name, class T, unsigned capacity>\012void pipe<name, T, capacity>::write(const T &data, bool &success) {\012  internal::HLS_CreatePipeFromPipeStorage_write<T>(&_storage);\012  success = _stream.tryWrite(data);\012}\012\012template<class name, class T, unsigned capacity>\012T pipe<name, T, capacity>::read() {\012  internal::HLS_CreatePipeFromPipeStorage_read<T>(&_storage);\012  return _stream.read(/*wait*/ true);\012}\012\012template<class name, class T, unsigned capacity>\012void pipe<name, T, capacity>::write(const T &data) {\012  internal::HLS_CreatePipeFromPipeStorage_write<T>(&_storage);\012  _stream.write(data);\012}\012\012#else // FPGA\012template<class name, class T, unsigned capacity>\012T pipe<name, T, capacity>::read(bool &success) {\012  internal::RPipe<T> p =\012      internal::HLS_CreatePipeFromPipeStorage_read<T>(&_storage);\012  T tempData;\012  success = !static_cast<bool>(\012      __builtin_intel_hls_read_pipe(p, &tempData, _size, _alignment));\012  return tempData;\012}\012\012template<class name, class T, unsigned capacity>\012void pipe<name, T, capacity>::write(const T &data, bool &success) {\012  internal::WPipe<T> p =\012      internal::HLS_CreatePipeFromPipeStorage_write<T>(&_storage);\012  success = !static_cast<bool>(\012      __builtin_intel_hls_write_pipe(p, &data, _size, _alignment));\012}\012\012template<class name, class T, unsigned capacity>\012T pipe<name, T, capacity>::read() {\012  internal::RPipe<T> p =\012      internal::HLS_CreatePipeFromPipeStorage_read<T>(&_storage);\012  T tempData;\012  __builtin_intel_hls_read_pipe_blocking(p, &tempData, _size,\012                                         _alignment);\012  return tempData;\012}\012\012template<class name, class T, unsigned capacity>\012void pipe<name, T, capacity>::write(const T &data) {\012  internal::WPipe<T> p =\012      internal::HLS_CreatePipeFromPipeStorage_write<T>(&_storage);\012  __builtin_intel_hls_write_pipe_blocking(p, &data, _size, _alignment);\012}\012#endif\012\012} // namespace ihc\012#endif\012#endif // __HLS_PIPES__\012"}, {"path":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/stdio.h", "name":"stdio.h", "has_active_debug_locs":false, "absName":"/packages/apps/fpga/Quartus/20.4/hls/include/HLS/stdio.h", "content":"/*  Copyright 1992-2020 Intel Corporation.                                 */\012/*                                                                         */\012/*  This software and the related documents are Intel copyrighted          */\012/*  materials, and your use of them is governed by the express license     */\012/*  under which they were provided to you (\"License\"). Unless the License  */\012/*  provides otherwise, you may not use, modify, copy, publish,            */\012/*  distribute, disclose or transmit this software or the related          */\012/*  documents without Intel's prior written permission.                    */\012/*                                                                         */\012/*  This software and the related documents are provided as is, with no    */\012/*  express or implied warranties, other than those that are expressly     */\012/*  stated in the License.                                                 */\012\012#ifndef __HLS_STDIO_H__\012#define __HLS_STDIO_H__\012\012#ifndef _STDIO_H\012#include <stdio.h>\012#endif\012\012#ifdef HLS_SYNTHESIS\012// Suppress if used in component\012# define printf(...) \012\012#endif //HLS_SYNTHESIS\012#endif //__HLS_STDIO_H__\012"}];
var alpha_viewer=false;